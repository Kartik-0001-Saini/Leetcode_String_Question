Question 290.) --> Word Pattern
Given a pattern and a string s, find if s follows the same pattern.

Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s. Specifically:

Each letter in pattern maps to exactly one unique word in s.
Each unique word in s maps to exactly one letter in pattern.
No two letters map to the same word, and no two words map to the same letter.

solution.) -->
class Solution {
public:
    bool wordPattern(string pattern, string s) {
        vector<string> word;
        string temp;

        stringstream ss(s);
        while(ss >> temp){
            word.push_back(temp);
        }

        if(word.size() != pattern.size()) return false;

        unordered_map<char, string> mp1;
        unordered_map<string, char> mp2;
        for(int i=0; i<pattern.size(); i++){
            char ch = pattern[i];
            string str = word[i];

            if(mp1.find(ch) != mp1.end() && mp1[ch] != str){
                return false;
            }
            if(mp2.find(str) != mp2.end() && mp2[str] != ch){
                return false;
            }
            mp1[ch] = str;
            mp2[str] = ch;
        }

        return 1;
    }
};


So in this question new things are :-
1.) Use of stringstream it is used to fetch a full word in the string like "dog cat dog" in this it fetch dog then cat then dog.
2.) We have to fetch data from string stream by '>>' and add in the vector it will work when in stream string a word is completely generated then it will push in the temp.
3.) Why we take two map function?
First map function ensure that one charter will match the same string.
Second map function ensures that one string will match the same charter.

Time Complexity :- O(n) + O(m)
O(n) --> for storing the value of string stream to vector.
O(m) --> for second for loop.
find function takes only O(1)
So overall time complexity is O(n).

Space Complexity :- O(n) 